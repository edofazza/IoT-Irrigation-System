\section{MQTT Network}

\subsection{Devices}
The MQTT Network will be deployed in the water provisioning site and it is formed by 4 nodes (2 Aquifer Level Detectors and 2 Reservoirs Level Detectors and Actuators). The role of those devices is to monitor the water level in the two sources, in order to always have it enough for the irrigation needs but without the spoil of natural resources. Each pair of devices communicates the sensed levels  to the Collector, which will compute the mean of the values to more precisely estimate the actual aquifer and reservoir level.


\subsection{Aquifer Level Detector}
The Aquifer Level Detector senses the level of water in the Aquifer, in order to estimate the availability. This device senses the height of the water flow in cm and based on that computes the volume of water that is available at each iteration, known the dimensions of the aquifer and the speed of the flow. The user can retrieve at any time the last measurement (the system will do it automatically) and the sensing interval is the same of the \textbf{tap\_interval}.

\subsubsection{Topics}
This device is subscribed to the \textbf{interval} topic used to change the sensing interval (to adapt it to the tap\_interval) and publishes measurements on the \textbf{aquifer\_level} MQTT topic.
The device acts as a MQTT client and handles its connection with the broker.

\subsubsection{Data Generation}
Data is generated every \textit{interval}, every time the system must decide from where to fetch water. The value for the aquifer sensor is updated according to the following idea: during rainy seasons, the level will be enough to cover the average water need, on the contrary during summer there can be risk of insufficient water coverage. The simulated value is then published as a MQTT message on the \textbf{aquifer\_level} topic.

\begin{lstlisting}
#define WATER_SPEED 0.0005    /* 0.0005cm/s   https://www.arpa.vda.it/it/acqua/acque-sotterranee/cosa-sono-le-acque-sotterranee */
#define SECTION 200             //2m
#define MAX_LEVEL 60           //60cm

static double simulate_level(){
    boolean summer = false;
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    int month = tm.tm_mon;
    if (month >=5 && month<8)  //between June and August
        summer = true;
    srand(time(NULL));
    double availability;  //   cm^3
    if (summer)
        availability = rand()%MEDIUM_NEED;
    else
        availability = MEDIUM_NEED + rand()%(VERY_HIGH_NEED - MEDIUM_NEED);

    //Assuming rectangular aquifer, available water is given by LEVEL * SECTION * WATER_SPEED * INTERVAL
    double level = ((availability/WATER_SPEED)/SECTION)/PUBLISH_INTERVAL;   //cm
    return level<MAX_LEVEL ? level : MAX_LEVEL;
}    
    
sensed_level = simulate_level();
sprintf(pub_topic, "aquifer_level");
//Assuming rectangular aquifer, available water is given by LEVEL * SECTION * WATER_SPEED * INTERVAL
available = sensed_level*SECTION*WATER_SPEED*PUBLISH_INTERVAL;
sprintf(app_buffer, "{\"node\": %d, \"aquifer_availability\": %.2f, \"unit\": \"cm^3\"}", node_id, available);
mqtt_publish(&conn, NULL, pub_topic, (uint8_t *)app_buffer, strlen(app_buffer), MQTT_QOS_LEVEL_0, MQTT_RETAIN_OFF);
printf("Sensed water level is: %.2f cm, aquifer water availability is %.2f cm^3\n", sensed_level, available);
\end{lstlisting}



\subsection{Reservoir Level Detector and Actuator}
The Reservoir Level Detector senses the level of water in the Reservoir, in order to estimate the availability. This device senses the height of the water storage in cm and based on that computes the volume of water that is available at each iteration, known the dimensions of the reservoir. The user can retrieve at any time the last measurement (the system will do it automatically) and the sensing interval is the same of the \textbf{tap\_interval}. The Reservoir Actuator instead puts or fetches water according to the decisions taken by the controller: if there is water abundance the actuator is asked to store the excess, when water lacks it is asked to fetch from the reservoir.

\subsubsection{Topics}
This device is subscribed to the \textbf{interval} topic used to change the sensing interval (to adapt it to the tap\_interval) and publishes measurements on the \textbf{reservoir\_level} MQTT topic.
The device acts as a MQTT client and handles its connection with the broker.

\subsubsection{Data Generation and Actuation Mechanism}
Data is generated every \textit{interval}, every time the system must decide from where to fetch water. The value for the reservoir level could be determined mathematically, but the deployment of a sensor allows to deal with possible phenomena like evaporation or breaks. The simulated value however is generated leaving out those phenomena, so it is always equal to the level that was present during the last actuation. The value is then published as a MQTT message on the \textbf{aquifer\_level} topic. The actuator instead receives commands from the controller through MQTT subscription and adds/removes the quantity of water indicated by the controller. 

\begin{lstlisting}
//assuming rectangular reservoirs of capacity 1000 litres
#define WIDTH 200             //2m = 200cm
#define DEPTH 100               //1m = 100cm
#define MAX_LEVEL 50           //50 cm
//Total capacity is 200*100*50 = 1e6 cm^3 = 1000 l

static double sensed_level=MAX_LEVEL;

static double simulate_level(){
    return sensed_level;
}

static void put_get_water(double quantity){
//assuming rectangular reservoir
    sensed_level += (quantity/WIDTH)/DEPTH;
    if (sensed_level>MAX_LEVEL)
        sensed_level = MAX_LEVEL;
    else if (sensed_level<0)
        sensed_level = 0;
}

int level = simulate_level();
sprintf(pub_topic, "reservoir_level");
//assuming rectangular reservoir, quantity (volume) is given by level*WIDTH*DEPTH
available = sensed_level*WIDTH*DEPTH;
sprintf(app_buffer, "{\"node\": %d, \"reservoir_availability\": %.2f, \"unit\": \"cm^3\"}", node_id, available);
mqtt_publish(&conn, NULL, pub_topic, (uint8_t *)app_buffer, strlen(app_buffer), MQTT_QOS_LEVEL_0, MQTT_RETAIN_OFF);
printf("Sensed water level is: %.2f cm, reservoir water availability is %.2f cm^3\n", sensed_level, available);


static void pub_handler(const char *topic, uint16_t topic_len, const uint8_t *chunk,  uint16_t chunk_len) {

  if(strcmp(topic, "interval") == 0) {
    printf("Changing detection interval to: ");

	long interval = atol(const char*)chunk;
    printf("%d\n", interval);
    PUBLISH_INTERVAL = interval;
  }
  else if(strcmp(topic, "set_level") == 0){
    char value[10];
    char *eptr;
    double quantity;
    strcpy(value, (const char*)chunk);
    quantity = strtod(value, &eptr);
    if (result == 0){
        /* If the value provided was out of range, display a warning message */
        if (errno == ERANGE)
            printf("The value provided was out of range\n");
        return;
    }
    printf("Changing reservoir water level by: %f\n", quantity);
    put_get_water(quantity);
  }
  else {
	  printf("Topic not recognized!\n");
  }
  return;
}


\end{lstlisting}



