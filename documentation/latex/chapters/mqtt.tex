\section{MQTT Network}

\subsection{Devices}
The MQTT Network will be deployed in the water provisioning site and it is formed by 4 nodes (2 Aquifer Level Detectors and 2 Reservoirs Level Detectors and Actuators). The role of those devices is to monitor the water level in the two sources, in order to always have it enough for the irrigation needs but without the spoil of the natural resources. Each pair of devices communicates the sensed levels  to the Collector, which will compute the mean of the values to more precisely estimate the actual aquifer and reservoir level.


\subsection{Aquifer Level Detector}
The Aquifer Level Detector senses the level of water in the Aquifer, in order to estimate the availability. This device senses the height of the water flow in cm and based on that computes the volume of water that is available at each iteration, known the dimensions of the aquifer and the speed of the flow. The user can retrieve at any time the last measurement (the system will do it automatically) and the sensing interval is the same of the \textbf{tap\_interval}.

\subsubsection{Topics}
This device is subscribed to the \textbf{interval} topic used to change the sensing interval to adapt it to the tap\_interval and publishes measurements on the \textbf{aquifer\_level} MQTT topic.
The device acts as a MQTT client and handles its connection with the broker.

\subsubsection{Data Generation}
Data is generated every \textit{interval}, every time the system must decide from where to fetch water. The value for the aquifer sensor is updated according to the following idea: during rainy seasons, the level will be enough to cover the average water need, on the contrary during summer there can be risk of insufficient water coverage. The simulated value is then published as a MQTT message on the \textbf{aquifer\_level} topic.

\begin{lstlisting}
#define WATER_SPEED 0.0005    /* 0.0005cm/s   https://www.arpa.vda.it/it/acqua/acque-sotterranee/cosa-sono-le-acque-sotterranee */
#define SECTION 200             //2m
#define MAX_LEVEL 60           //60cm

static double simulate_level(){
    boolean summer = false;
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    int month = tm.tm_mon;
    if (month >=5 && month<8)  //between June and August
        summer = true;
    srand(time(NULL));
    double availability;  //   cm^3
    if (summer)
        availability = rand()%MEDIUM_NEED;
    else
        availability = MEDIUM_NEED + rand()%(VERY_HIGH_NEED - MEDIUM_NEED);

    //Assuming rectangular aquifer, available water is given by LEVEL * SECTION * WATER_SPEED * INTERVAL
    double level = ((availability/WATER_SPEED)/SECTION)/PUBLISH_INTERVAL;   //cm
    return level<MAX_LEVEL ? level : MAX_LEVEL;
}    
    
sensed_level = simulate_level();
sprintf(pub_topic, "aquifer_level");
//Assuming rectangular aquifer, available water is given by LEVEL * SECTION * WATER_SPEED * INTERVAL
available = sensed_level*SECTION*WATER_SPEED*PUBLISH_INTERVAL;
sprintf(app_buffer, "{\"node\": %d, \"aquifer_availability\": %.2f, \"unit\": \"cm^3\"}", node_id, available);
mqtt_publish(&conn, NULL, pub_topic, (uint8_t *)app_buffer, strlen(app_buffer), MQTT_QOS_LEVEL_0, MQTT_RETAIN_OFF);
printf("Sensed water level is: %.2f cm, aquifer water availability is %.2f cm^3\n", sensed_level, available);
\end{lstlisting}



\subsection{Reservoir Level Detector and Actuator}
Soil moisture sensors measure the water content in the soil and can be used to estimate the amount of stored water in the soil horizon. Soil moisture sensors do not measure water in the soil directly. Instead, they measure changes in some other soil property that is related to water content in a predictable way. Checking the different technologies used for measure soil moisture content, we decide to exploit the \textit{soil water potential}\footnote{\textit{Soil water potential} or \textit{soil moisture tension} is a measurement of how tightly water clings to the soil and is expressed in units of pressure called bars. Generally, the drier the soil, the greater the soil water potential and the harder a plant must work to draw water from the soil.}.

\subsubsection{Topics}
The soil moisture sensor exposes two resources: the \textit{soil\_moisture\_sensor} and the \textit{soil\_moisture\_switch} resources.

The \textbf{soil\_moisture\_sensor} resource is an observable resource that provides to the clients the soil moisture tension acquired by the sensor. The resource not only provides the mere tension to the clients, but it informs if the value is lower or greater than a certain threshold. Hence, the sensor exposes a  \textit{PUT} method, in order to set up the lower or the upper bound for the tension\footnote{For the default range value we used the ones indicated here: https://www.metergroup.com/environment/articles/defining-water-potential/ }.

The change of the bounds is done at step, the user will specify the threshold that he/she wants to change through the CLI: upper or lower. At the server side the request will be processed checking if the value arrived is consistent (e.g., the new value for the lower bound is not greater than the upper bound actual value), after those controls the parameter is updated.

The \textbf{soil\_moisture\_switch} resource is connected to the \textit{isActive} boolean variable, which indicates if the sensor is operating or not. This is done for turning off the temperature sensor when it is raining in order to save energy, since we do not perform any analysis for irrigating when the weather does that for us. For the reason that we want to change the status of the resources based on the rain sensor, it is implemented a \textit{PUT} method for changing the value of the \textit{isActive} variable.

\subsubsection{Data Generation}
Data is generated every \textit{CLOCK\_SECOND} in order to have a rapid simulation. The value for the tension is updated using the following algorithm (the same of to the one used for the temperature):

\begin{lstlisting}
static void soil_moisture_event_handler(void)
{
    if (!isActive) {
        return; // DOES NOTHING SINCE IT IS TURNED OFF
    }
    
    // extimate new tension
    srand(time(NULL));
    int new_soilTension = soilTension;
    int random = rand() % 4; // generate 0, 1, 2, 3
    
    if (random == 0) // 25% of changing the value
        if (random < 2) // decrease
            new_soilTension -= VARIATION;
        else // increase
            new_soilTension += VARIATION;

    // if not equal
    if (new_soilTension != soilTension)
    {
        soilTension = new_soilTension;
        coap_notify_observers(&soil_moisture_sensor);
    }
}
\end{lstlisting}



